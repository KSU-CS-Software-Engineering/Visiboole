	  Visiboole Syntax
  ====================================
  
  Boolean evaluations:
  	  Spaces ' ' between variables indicates the AND operator.
  	  	  B2 = A2 A1 A0; translates to B2 is equal to A2 AND A1 AND A0
  	  A plus '+' between variables indicates the OR operator.
  	  	  B2 = A2 + A1 + A0; translates to B2 is equal to A2 OR A1 OR A0
  	  A tilde '~' indicates NOT - following the rules above
  	  A caret '^' indicates XOR - following the rules above
  	  
  Formatting:
  	  Visiboole is not strict on spaces or tabs, with the exception that tabs cannot be used in AND statements
  	  
  ////////Have John elaborate
  	  Parenthesis '()' forces the inner statements to evaluate before any others, effectively superseding the Left to Right order of operations
  	  Brackets '[]' indicates a vector - the formatting for declaring vectors are shown below
  	  Braces '{}' represent concatenation
  	  These above grouping operators must match. for every open parenthesis requires one and only one closing parenthesis, and so on
  	  Equals '=' assigns the left side (A dependent variable) to the resulting evaluation
  	  	  of any number of operations performed with any number of dependent or independent variables
  	  An asterisk '*' before the declaration of an independent variable initializes it to true
  	  
  Constants:
  	  The following constant types are supported
  	  'b explicitly defines your constant as a binary (Base 2) value (The example of vector declaration is above)
  	  'd explicitly defines your constant as a decimal (Base 10) value
  	  	  Visiboole converts this to the appropriate binary value:
  	  	  	  Assing a vector as  'd8   would assign the components of the vector 1 0 0 0 respectively
  	  'h explicitly defines your constant as a hexadecimal (Base 16) value
  	  	  Visiboole converts this in the same way as above
  	  	  
  ////unsigned
  	  	  
  Single instance variables:
  	  Variables must be assigned with a unique letter and number combination (in that order)
  	  	  A0 , AA99
  	  	  
  	  	  *Variables must be declared as a single instance OR as a vector
  	  	  	  if A0 is typed is declared, later you will be unable to declare the vector A[3..1]
  	  	  	  the opposite is true A[3..0] causes the later declaration of A4 to fail
  	  	  
  Vectors:
  
  	  Declaration:
  	  
  	  Vectors may be used undeclared, and are then declared upon their use
  	  Vectors are declared with a variable name followed by the bounds:
  	  	  A[2..0] - represents A2 as the 'upper bound' and A0 as the 'lower bound'
  	  	  	  by default, variables will be declared to fill the bounds
  	  	  	  	  A[3..1] - A3 A2 A1
  	  	  A[6.2.0] - represents A6 as the 'upper bound' and A0 as the 'lower bound'
  	  	  	  the middle operator represents the interval between variables
  	  	  	  	  A[6.2.0] - A6 A4 A2 A0
  	  	  	  	  
  	  These vectors may be used undeclared in boolean evaluations
  	  	  A[2..0] = B[2..0] + C[2..0] which would expand to
  	  	  A2 = B2 + C2
  	  	  A1 = B1 + C1 ... etc
  	  	  
  	  	  declaring any undeclared variables
  	  
  	  Assignments:
  	  
  	  Ending the statement after a declaration will expand the bounds and assign to 0/false
  	  You may assign the created variables to the value of other variables or boolean evaluations
  	  
  	  The number of expanded variables must be equal to the number on the right side, alternatively a scalar may be used
  	  
  	  A[2..0] = B[2..0] will create the variables A2 A1 A0, each of which is now dependent on B2, B1, B0 respectively
  	  A[2..0] = C0 will make every variable in the vector dependent on the value of C0
  	  Constants can be used to initialize the variables of the vector to the binary values of a constant
  	  	  A[3..0] = 'd8
  	  	  	  'd8 will translate to its binary value 1000
  	  	  	  The expansion of the vector will assign A3 as 1, A2 as 0, A1 as 0, and A0 as 0
  	  	  	  all of the above constant types are supported, 'b, 'd, 'h and unsigned
  
  Concatenation:
  	  Concatenation allows the use of vectors without declaration
  	  These vectors can contain both undeclared and declared variables
  	  The primary use is when assigning a vector to variables of multiple namespaces
  	  A concatenation requires more than one variable, separated with commas
  	  
  	  A[2..0] = {B2, B1, B0} constructs a vector of the right hand side of the evaluation, which evaluates similarly to a simple vector declaration
  	  	  *This is a single namespace initialization, and is more verbose than a simple vector intialization
  	  	  
  	  A[2..0] = {D1, C1, B1} would create the following
  	  	  A2 = D1, A1 = C1, A0 = B1
  	  Vector expansions are allowed in a concatenation
  	  A[3..0] = {C[2..0], B0} would create the following
  	  	  A3 = C2, A2 = C1, A1 = C0, A0 = B1
  	  	  
  	  As in vector assignments, there must be equal numbers of expanded variables on both sides
  	  
  	  Concatenation can also be used in boolean evaluations
  	  A[2..0] = {B0, C0, D0} {E0, F0, G0}
  	  Undeclared vectors may be used in place of the above
  	  A[2..0] = {B[1..0], C0} {D[1..0], E0}
  	  
  Different clock statements
  ////John's wording	  